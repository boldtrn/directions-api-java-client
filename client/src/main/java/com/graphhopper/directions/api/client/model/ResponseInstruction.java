/*
 * GraphHopper Directions API
 * You use the GraphHopper Directions API to add route planning, navigation and route optimization to your software. E.g. the Routing API has turn instructions and elevation data and the Route Optimization API solves your logistic problems and supports various constraints like time window and capacity restrictions. Also it is possible to get all distances between all locations with our fast Matrix API.
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package com.graphhopper.directions.api.client.model;

import java.util.Objects;
import com.google.gson.annotations.SerializedName;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.util.ArrayList;
import java.util.List;

/**
 * ResponseInstruction
 */

public class ResponseInstruction {
  @SerializedName("text")
  private String text = null;

  @SerializedName("street_name")
  private String streetName = null;

  @SerializedName("distance")
  private Double distance = null;

  @SerializedName("time")
  private Integer time = null;

  @SerializedName("interval")
  private List<Integer> interval = new ArrayList<Integer>();

  @SerializedName("sign")
  private Integer sign = null;

  @SerializedName("annotation_text")
  private String annotationText = null;

  @SerializedName("annotation_importance")
  private Integer annotationImportance = null;

  @SerializedName("exit_number")
  private Integer exitNumber = null;

  @SerializedName("turn_angle")
  private Double turnAngle = null;

  public ResponseInstruction text(String text) {
    this.text = text;
    return this;
  }

   /**
   * A description what the user has to do in order to follow the route. The language depends on the locale parameter.
   * @return text
  **/
  @ApiModelProperty(example = "null", value = "A description what the user has to do in order to follow the route. The language depends on the locale parameter.")
  public String getText() {
    return text;
  }

  public void setText(String text) {
    this.text = text;
  }

  public ResponseInstruction streetName(String streetName) {
    this.streetName = streetName;
    return this;
  }

   /**
   * The name of the street to turn onto in order to follow the route.
   * @return streetName
  **/
  @ApiModelProperty(example = "null", value = "The name of the street to turn onto in order to follow the route.")
  public String getStreetName() {
    return streetName;
  }

  public void setStreetName(String streetName) {
    this.streetName = streetName;
  }

  public ResponseInstruction distance(Double distance) {
    this.distance = distance;
    return this;
  }

   /**
   * The distance for this instruction, in meter
   * @return distance
  **/
  @ApiModelProperty(example = "null", value = "The distance for this instruction, in meter")
  public Double getDistance() {
    return distance;
  }

  public void setDistance(Double distance) {
    this.distance = distance;
  }

  public ResponseInstruction time(Integer time) {
    this.time = time;
    return this;
  }

   /**
   * The duration for this instruction, in ms
   * @return time
  **/
  @ApiModelProperty(example = "null", value = "The duration for this instruction, in ms")
  public Integer getTime() {
    return time;
  }

  public void setTime(Integer time) {
    this.time = time;
  }

  public ResponseInstruction interval(List<Integer> interval) {
    this.interval = interval;
    return this;
  }

  public ResponseInstruction addIntervalItem(Integer intervalItem) {
    this.interval.add(intervalItem);
    return this;
  }

   /**
   * An array containing the first and the last index (relative to paths[0].points) of the points for this instruction. This is useful to know for which part of the route the instructions are valid.
   * @return interval
  **/
  @ApiModelProperty(example = "null", value = "An array containing the first and the last index (relative to paths[0].points) of the points for this instruction. This is useful to know for which part of the route the instructions are valid.")
  public List<Integer> getInterval() {
    return interval;
  }

  public void setInterval(List<Integer> interval) {
    this.interval = interval;
  }

  public ResponseInstruction sign(Integer sign) {
    this.sign = sign;
    return this;
  }

   /**
   * A number which specifies the sign to show e.g. for right turn etc <br>TURN_SHARP_LEFT = -3<br>TURN_LEFT = -2<br>TURN_SLIGHT_LEFT = -1<br>CONTINUE_ON_STREET = 0<br>TURN_SLIGHT_RIGHT = 1<br>TURN_RIGHT = 2<br>TURN_SHARP_RIGHT = 3<br>FINISH = 4<br>VIA_REACHED = 5<br>USE_ROUNDABOUT = 6
   * @return sign
  **/
  @ApiModelProperty(example = "null", value = "A number which specifies the sign to show e.g. for right turn etc <br>TURN_SHARP_LEFT = -3<br>TURN_LEFT = -2<br>TURN_SLIGHT_LEFT = -1<br>CONTINUE_ON_STREET = 0<br>TURN_SLIGHT_RIGHT = 1<br>TURN_RIGHT = 2<br>TURN_SHARP_RIGHT = 3<br>FINISH = 4<br>VIA_REACHED = 5<br>USE_ROUNDABOUT = 6")
  public Integer getSign() {
    return sign;
  }

  public void setSign(Integer sign) {
    this.sign = sign;
  }

  public ResponseInstruction annotationText(String annotationText) {
    this.annotationText = annotationText;
    return this;
  }

   /**
   * optional - A text describing the instruction in more detail, e.g. like surface of the way, warnings or involved costs.
   * @return annotationText
  **/
  @ApiModelProperty(example = "null", value = "optional - A text describing the instruction in more detail, e.g. like surface of the way, warnings or involved costs.")
  public String getAnnotationText() {
    return annotationText;
  }

  public void setAnnotationText(String annotationText) {
    this.annotationText = annotationText;
  }

  public ResponseInstruction annotationImportance(Integer annotationImportance) {
    this.annotationImportance = annotationImportance;
    return this;
  }

   /**
   * optional - 0 stands for INFO, 1 for warning, 2 for costs, 3 for costs and warning
   * @return annotationImportance
  **/
  @ApiModelProperty(example = "null", value = "optional - 0 stands for INFO, 1 for warning, 2 for costs, 3 for costs and warning")
  public Integer getAnnotationImportance() {
    return annotationImportance;
  }

  public void setAnnotationImportance(Integer annotationImportance) {
    this.annotationImportance = annotationImportance;
  }

  public ResponseInstruction exitNumber(Integer exitNumber) {
    this.exitNumber = exitNumber;
    return this;
  }

   /**
   * optional - Only available for USE_ROUNDABOUT instructions. The count of exits at which the route leaves the roundabout.
   * @return exitNumber
  **/
  @ApiModelProperty(example = "null", value = "optional - Only available for USE_ROUNDABOUT instructions. The count of exits at which the route leaves the roundabout.")
  public Integer getExitNumber() {
    return exitNumber;
  }

  public void setExitNumber(Integer exitNumber) {
    this.exitNumber = exitNumber;
  }

  public ResponseInstruction turnAngle(Double turnAngle) {
    this.turnAngle = turnAngle;
    return this;
  }

   /**
   * optional - Only available for USE_ROUNDABOUT instructions. The radian of the route within the roundabout - 0&lt;r&lt;2*PI for clockwise and -2PI&lt;r&lt;0 for counterclockwise transit. Null if the direction of rotation is undefined.
   * @return turnAngle
  **/
  @ApiModelProperty(example = "null", value = "optional - Only available for USE_ROUNDABOUT instructions. The radian of the route within the roundabout - 0&lt;r&lt;2*PI for clockwise and -2PI&lt;r&lt;0 for counterclockwise transit. Null if the direction of rotation is undefined.")
  public Double getTurnAngle() {
    return turnAngle;
  }

  public void setTurnAngle(Double turnAngle) {
    this.turnAngle = turnAngle;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ResponseInstruction responseInstruction = (ResponseInstruction) o;
    return Objects.equals(this.text, responseInstruction.text) &&
        Objects.equals(this.streetName, responseInstruction.streetName) &&
        Objects.equals(this.distance, responseInstruction.distance) &&
        Objects.equals(this.time, responseInstruction.time) &&
        Objects.equals(this.interval, responseInstruction.interval) &&
        Objects.equals(this.sign, responseInstruction.sign) &&
        Objects.equals(this.annotationText, responseInstruction.annotationText) &&
        Objects.equals(this.annotationImportance, responseInstruction.annotationImportance) &&
        Objects.equals(this.exitNumber, responseInstruction.exitNumber) &&
        Objects.equals(this.turnAngle, responseInstruction.turnAngle);
  }

  @Override
  public int hashCode() {
    return Objects.hash(text, streetName, distance, time, interval, sign, annotationText, annotationImportance, exitNumber, turnAngle);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ResponseInstruction {\n");
    
    sb.append("    text: ").append(toIndentedString(text)).append("\n");
    sb.append("    streetName: ").append(toIndentedString(streetName)).append("\n");
    sb.append("    distance: ").append(toIndentedString(distance)).append("\n");
    sb.append("    time: ").append(toIndentedString(time)).append("\n");
    sb.append("    interval: ").append(toIndentedString(interval)).append("\n");
    sb.append("    sign: ").append(toIndentedString(sign)).append("\n");
    sb.append("    annotationText: ").append(toIndentedString(annotationText)).append("\n");
    sb.append("    annotationImportance: ").append(toIndentedString(annotationImportance)).append("\n");
    sb.append("    exitNumber: ").append(toIndentedString(exitNumber)).append("\n");
    sb.append("    turnAngle: ").append(toIndentedString(turnAngle)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }
  
}

